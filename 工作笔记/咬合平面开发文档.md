# 咬合平面开发文档

### 1 产品需求

[《1118-UPCAD咬合平面步骤》](https://alidocs.dingtalk.com/i/nodes/qnYMoO1rWxDLXpEpi6evawDOW47Z3je9?doc_type=wiki_doc)

### 2 开发流程

### 2.1 UI开发

咬合平面的UI没什么可以说的，按照正常流程编写即可，唯一的问题是需要并入撤销恢复的组件。这是一个项目原有的组件，在构建时是以外部组件的方式写入的。还要注意链接一下信号槽。

```c++
impl_->historyList_->setFuntionId(FUNID_OCCPLANE_EDIT);
connect(historyWidget, &HistoryList::signalUndo
	, this, [this](const std::vector<std::pair<int, int>>& historyWidget) {impl_->slotUndoFromHistoryList(historyWidget); });
connect(historyWidget, &HistoryList::signalRedo
	, this, [this](const std::vector<std::pair<int, int>>& historyWidget) {impl_->slotRedoFromHistoryList(historyWidget); });
```

###  2.2 撤销恢复

既然提到撤销恢复，这里就具体说一下。

![image.png](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4ny578xDxenLbj/img/299f12c0-e4d7-4cec-aecc-129c7f22b8ee.png)

前面2.1中使用的类为_HistoryList_,他只是一个QWidget,看起来并不存在真正的数据栈以便保存恢复。因此，我自己写了一个比较建议的保存恢复栈。

```c++
#include <stack>
namespace HistoryUndoRedoManagerSpace
{
	///HandlerType表示通过事件推入栈，其同时也是UndoType
	enum class PushType
	{
		RedoType = 0,
		UndoType = 1,
		HandlerType = 2
	};
}
template <typename T>
class  HistoryUndoRedoManager
{
public:
	void push(const T data, HistoryUndoRedoManagerSpace::PushType);

	T redo();

	T undo();

	bool empty();
	void clear();
private:
	void clearRedo();
	void clearUndo();
private:
	std::stack<T> redoList_;
	std::stack<T> undoList_;
};
```

这是一个非常简单的栈，支持任意类型。**因为保存恢复往往是对数据的完整备份，所以我这里使用按值传递的方式压入栈。当然，一般都是在外部new数据后，这里传入的是指针。所以外部数据往往需要做深拷贝后传入指针进来。**这个部分需要明确，否则很容易导致undo后原始数据被修改了。

这里还加了一种压栈类型HandlerType，这个用法是对于非快捷键撤销恢复使用的，也就是说是真正传入了数据。他的主要区别在于需要清空已有的redo栈。而快捷键的撤销恢复只是把数据在undo，redo栈中来回倒腾。

此外，快捷键的撤销恢复逻辑可能有点绕，这里说明一下：

```c++
//是撤销类型，需要把当前操作压入redo栈中
//是恢复类型，需要把当前操作压入undo栈中
std::shared_ptr<HistoryDataInfo>data;
switch (type)
{
  case HistoryUndoRedoManagerSpace::PushType::RedoType:
    redo(data);
    if (!data)
      return;
    pushUseDataHandler(meshInfoHistoryData_, PushType::UndoType);
    break;
  case HistoryUndoRedoManagerSpace::PushType::UndoType:
    undo(data);
    if (!data)
      return;
    pushUseDataHandler(meshInfoHistoryData_, PushType::RedoType);
    break;
}
meshInfoHistoryData_ = data;
restoreMeshInfoByHistory(meshInfoHistoryData_);
```

对于，撤销类型，即按下ctrl+z，我们先从undo栈中获取数据data，然后把当前的数据压入redo栈中，然后根据data数据恢复。其实也能理解，因为按下ctrl+z后，我们下一步自然能够按下ctrl+Y，而这份数据就是前面提到的压入redo栈中的数据。

2.3 选中模型,绘制边缘线

直接上代码：

```c++
void OccPlaneManager::PImpl::doSetMeshSelect(bool select)
{
	if (select)
	{
		meshInfoHistoryData_->mat = jawMeshNode_->getWorldMatrix();
		transMeshHandler_->setVaild(true);
		//当然这边也可以高亮显示一下TODO
		drawOutLine();
		//禁止旋转，只允许缩放
		render_->setActionMask(TA_SCALE);
	}
	else
	{
		hasSelectMesh_ = false;
		transMeshHandler_->setVaild(false);
		//取消高亮
		clearOutLine();
		//重新恢复场景漫游
		render_->setActionMask(TA_DESIGN);
	}
	render_->render();
}
```

这里的在旋转模型后，绘制边缘线，并禁止场景漫游旋转，开启拖拽漫游器。

目前的边缘高亮是这么写的：

```c++
void OccPlaneManager::PImpl::drawOutLine()
{
	std::shared_ptr<core::IMesh> iMesh = jawMesh_->asIMesh();
	////保存原始的Mesh颜色
	//if (meshColor_.empty())
	//	meshColor_ = *iMesh->getSecondColor();

	IntVector indexVec;
	jawMesh_->getBoundaryVertexList(indexVec);

	std::set<int> borderIndex;
	for (const auto& index : indexVec)
	{
		IntVector ringIndexVec;
		jawMesh_->getRingVertex(index, ringIndexVec);
		borderIndex.insert(ringIndexVec.begin(), ringIndexVec.end());
	}

	for (auto& item : borderIndex)
	{
		core::SecondVertSet v;
		v.insert(item);
		meshColor_.insert({ item ,(*iMesh->getSecondColor())[item] });
		iMesh->createSecondData(item, v, Point3f(225. / 255., 225. / 255, 225. / 255), false);
	}
	iMesh->updateAllSecondData(true);
	iMesh->setSecondColorEnabled(true);
	iMesh->notifyRenderSecondColor();
}
```

简单来说，就是找模型的边缘点集，赋值一下颜色。这里特意提一下的理由其实是想说这块可以用Shader来写，但是目前不知道该怎么弄。

### 2.3 七边形咬合平面

这个也是写这篇文档的主要目的

1.  点集生成
    

根据图片，生成点集。

这是原始图片：

![image.png](https://alidocs.oss-cn-zhangjiakou.aliyuncs.com/res/8K4ny578xDxenLbj/img/15a22d31-b60a-4169-8761-8ce8efc2c37f.png)

2.  根据AI写了一个建议的python脚本，输出外圈的点集
    

```python
import cv2
import numpy as np
print(cv2.__version__)

# 读取图像
image = cv2.imread('F:/QuickToolCode/SampleOccplane/Vector.png')
height, width, _ = image.shape
cv2.imshow("vecort",image)
cv2.waitKey()

# 转换为灰度图像
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
cv2.imshow("vecort",gray)
cv2.waitKey()

# 边缘检测
edges = cv2.Canny(gray, 50, 150)
cv2.imshow("vecort",edges)
cv2.waitKey()

# 查找轮廓
contour_2d, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
# 绘制轮廓
cv2.drawContours(gray, contour_2d, -1, (0, 255, 0), 3)  # -1 表示绘制所有轮廓，(0, 255, 0) 是绘制颜色（绿色），3 是线条粗细
cv2.imshow("Contours", gray)
cv2.waitKey(0)

# 提取第一个轮廓（假设只有一个主要轮廓）
if contour_2d:
    contour_2d = contour_2d[0].reshape(-1, 2)
    # 计算图像中心坐标
    center_x = width / 2
    center_y = height / 2
    # 将轮廓点的 x 和 y 坐标转换为以中心为原点
    centered_contour_2d = contour_2d - np.array([center_x, center_y])
    # 计算归一化因子
    norm_factor_x = 2 / width
    norm_factor_y = 2 / height
    # 归一化轮廓点的 x 和 y 坐标到 [-1, 1]
    normalized_contour_2d = centered_contour_2d * np.array([norm_factor_x, -norm_factor_y])
    # 获取轮廓点的数量
    num_points = normalized_contour_2d.shape[0]
    # 创建 z 坐标数组（全为 0）
    z_coords = np.zeros((num_points, 1))
    # 组合 x, y, z 坐标
    normalized_contour_3d = np.hstack((normalized_contour_2d, z_coords))
    print(normalized_contour_3d)
    # 打开文件进行写入
    with open('D:/UPCAD2024/upcad/bin.x64/Resource/skins/classic/panel_images/OccPlane/occPlaneShape.txt', 'w') as f:
        for point in normalized_contour_3d:
            x, y, z = point
            f.write(f"{x},{y},{z}\n")
    
    
```

最后在指定位置输出_occPlaneShape.txt，注意，这里输出的点集是以图片中心点为（0,0,0）点的$[-1,1]^3$。

3.  C++ 读取数据
    

```c++
QString occPlanePointsPath = QApplication::applicationDirPath() + "/Resource/skins/classic/panel_images/OccPlane/occPlaneShape.txt";
std::vector<Point3f> pointSet;
std::ifstream file(occPlanePointsPath.toStdString());
if (file.is_open()) {
	std::string line;
	while (std::getline(file, line)) {
		std::stringstream ss(line);
		float x, y, z;
		char comma;
		if (ss >> x >> comma >> y >> comma >> z) {
			pointSet.emplace_back(x, y, z);
		}
		else {
			std::cerr << "Error parsing line: " << line << std::endl;
		}
	}
	file.close();
}
else {
	std::cerr << "Could not open the file." << std::endl;
	return;
}
```

通过这种方式，读取txt，并将其存储到_pointSet_，注意，此时的平面为x,y轴上的，需要将其转换到特定的位置。